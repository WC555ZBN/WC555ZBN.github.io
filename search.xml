<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis多级缓存-场景</title>
      <link href="/2020/02/10/redis-ti-sheng/"/>
      <url>/2020/02/10/redis-ti-sheng/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis多级缓存-场景"><a href="#Redis多级缓存-场景" class="headerlink" title="Redis多级缓存-(场景)"></a>Redis多级缓存-(场景)</h1><h2 id="按照粒度由粗到细-场景"><a href="#按照粒度由粗到细-场景" class="headerlink" title="按照粒度由粗到细(场景)"></a>按照粒度由粗到细(场景)</h2><h3 id="1-页面级缓存-了解不够-望各位拓展"><a href="#1-页面级缓存-了解不够-望各位拓展" class="headerlink" title="1.页面级缓存(了解不够,望各位拓展)"></a>1.页面级缓存(了解不够,望各位拓展)</h3><p>​    有时也叫url级别缓存,将页面手动渲染存到Redis(key =key=商品id,val=”商品详情页面，以后再次请求这个页面时，从redis中获取，直接向前端返回text/html,并且可以告诉浏览器在本地缓存该页面,缺点是页面数据更新不及时)</p><h3 id="2-对象级别缓存"><a href="#2-对象级别缓存" class="headerlink" title="2.对象级别缓存"></a>2.对象级别缓存</h3><p>​    如商品数据，（key=  商品id，val=“数据库查出的商品数据”）将查询过一次的商品信息存到redis，第二次请求改商品数据时，优先到redis查询</p><h2 id="redis做缓存的思路"><a href="#redis做缓存的思路" class="headerlink" title="redis做缓存的思路"></a>redis做缓存的思路</h2><p>1.先检查redis有无数据</p><p>​    a: 有就直接返回</p><p>​    b:没有查询数据库,把数据存入redis,再返回</p><p>2.注意缓存的生命周期</p><p>​    如果周期是永久,那么redis很容易崩掉,只是时间问题</p><h2 id="既然说到了生命周期那就说下过期键的删除策略"><a href="#既然说到了生命周期那就说下过期键的删除策略" class="headerlink" title="既然说到了生命周期那就说下过期键的删除策略"></a>既然说到了生命周期那就说下过期键的删除策略</h2><p>​    三种不同的删除策略</p><p>​    1.在设置键的过期时间时，创建一个回调事件，当过期时间达到时，由时间处理器自动执行键的删除操作</p><p>​    2.惰性删除。键过期了就过期了，不管。每次从dict字典中按key取值时，先检查此key是否已经过期，如果过期了就删除它，并返回nil，如果没过期，就返回键值</p><p>​    3.定时删除。每隔一段时间，对expires字典进行检查，删除里面的过期键</p><p>这样我们可以看到第一种和第三种为被动删除,第二种为主动删除,且第一种实时性更高</p><h3 id="立即删除"><a href="#立即删除" class="headerlink" title="立即删除"></a>立即删除</h3><p>​    立即删除能保证内存中数据的最大新鲜度,因为它保证过期键值会在过期后马上被删除,其所占用的内存也会随之释放,但是立即删除对cpu不友好,因为删除操作会占用cpu的时间,如果刚好碰到cpu很忙的时候,比如正在做交集或排序等计算的时候,就会给cpu造成造成额外的压力</p><p>​    而且目前redis事件处理器对时间事件的处理方式 —无序链表,查找一个key的时间复杂度为O(n),所有并不适合来处理大量的时间事件</p><h3 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h3><p>​    惰性删除是指，某个键值过期后，此键值不会马上被删除，而是等到下次被使用的时候，才会被检查到过期，此时才能得到删除。所以惰性删除的缺点很明显:浪费内存。dict字典和expires字典都要保存这个键值的信息</p><p>​    举个例子，对于一些按时间点来更新的数据，比如log日志，过期后在很长的一段时间内可能都得不到访问，这样在这段时间内就要拜拜浪费这么多内存来存log.这对于性能非常依赖于内存太小的redis来说,是比较致命的</p><h3 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h3><p>从上面分析来看，立即删除会短时间内占用大量cpu，惰性删除会在一段时间内浪费内存，所以定时删除是一个折中的办法。</p><p>定时删除是:每隔一段时间执行一次删除操作，并通过限制删除操作执行的时长和频率，来减少删除操作对cpu的影响。另一方面定时删除也有效的减少了因惰性删除带来的内存浪费</p><h3 id="总结策略"><a href="#总结策略" class="headerlink" title="总结策略"></a>总结策略</h3><p>redis使用的过期键值删除策略是：惰性删除加上定期删除，两者配合使用</p><h2 id="redis在秒杀中使用"><a href="#redis在秒杀中使用" class="headerlink" title="redis在秒杀中使用"></a>redis在秒杀中使用</h2><ol><li><p>先将秒杀商品库存预存到redis</p></li><li><p>秒杀开始后,在redis中预减库存，减为0该商品秒杀结束(redis是单线程-&gt;原子性)</p></li><li><p>如果为了减轻对redis的访问压力，可以将用户提交的秒杀请求放到mq（比RabbitMq)中,</p><p>比如一共只有10件商品,一共10万用户都几乎同一时间提交秒杀请求</p><p>1.可以将请求放到消息队列中，返回给前端是“排队中”</p><p>2.消费者(队列的”消费者“）按照固定的速度从消息队列中取数据，创建订单到数据库（也就有条不紊的创建10个订单，数据库0冲击</p><p>3.虽然有可能是排到前10的用户，如果由于某种原因创建订单失败，就会将该用户的秒杀请求放到mq尾部，接着给队列中的其他用户创建订单</p><p>4.创建订单成功的请求，将该请求从mq中移除，对用户发送短信”恭喜，秒杀成功！“</p><p>5.成功创建10个订单之后（也就是秒杀结束），给队列中其他用户请求返回”秒杀失败“</p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis简介</title>
      <link href="/2020/01/30/redis-jian-jie/"/>
      <url>/2020/01/30/redis-jian-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h1><h2 id="希望各位看官大人能耐心的看下去-我觉得会带给你们收获"><a href="#希望各位看官大人能耐心的看下去-我觉得会带给你们收获" class="headerlink" title="希望各位看官大人能耐心的看下去,我觉得会带给你们收获"></a>希望各位看官大人能耐心的看下去,我觉得会带给你们收获</h2><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>​    redis是一个开源(BSD许可)的,内存中数据结构存储系统,它可以用作数据库,缓存和消息中间件.它支持多种类型的数据结构,如字符串(Strings),散列(hashes),列表(lists),集合(sets),有序集合(sorted sets)与范围查询,bitmaps,hyperloglogs和地理空间(geospatial)索引半径查询,Redis内置了复制(replication),LUA脚本(Lua scripting),LRU驱动事件(LRU eviction)，事务(transactions )和不同级别的持久化硬盘(persistenece),并通过Redis哨兵(Sentinel)和自动分区(Cluster)提高可用性(high availability )</p><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>在官方给的bench-mark数据中:测试完成了50个并发执行100000请求设置和获取的值是一个256字节字符串,结果:读的速度是110000次/s,写的速度是81000次/s</p><h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>2008年,意大利一家创业公司Merzia的创始人Salvatore Sanfilippo为了避免MySQL的低性能，亲自定做一个数据库，并于2009年开发完成，这个就是Redis </p><p>从2010年3月15日起，Redis的开发工作由VMware主持 </p><p>从2013年5月开始，Redis的开发由Pivotal赞助</p><p>说明:Pivotal公司是由EMC和VMware联合成立的一家新公司。Pivotal希望为新一代的应用提供一个原生的基础，建立在具有领导力的云和网络公司不断转型的IT特性之上。Pivotal的使命是推行这些创新，提供给企业IT架构师和独立软件提供商</p><h2 id="支持的语言"><a href="#支持的语言" class="headerlink" title="支持的语言"></a>支持的语言</h2><table><thead><tr><th>ActionScript</th><th>Common Lisp</th><th>Haxe</th><th>Objectiv-C</th><th>R</th></tr></thead><tbody><tr><td>C</td><td>Dart</td><td>Io</td><td>Perl</td><td>Ruby</td></tr><tr><td>C++</td><td>Erlang</td><td>Java</td><td>PHP</td><td>Scala</td></tr><tr><td>C#</td><td>Go</td><td>Node.js</td><td>Pure Data</td><td>Smalltalk</td></tr><tr><td>Clojure</td><td>Haskell</td><td>Lua</td><td>Python</td><td>Tcl</td></tr></tbody></table><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>对于redis进行一些常用操作,我们经常说,Redis的set,get以及hset等等命令的执行都是原子性的,但是令自己百思不得其解的是,为什么这些操作是原子性</p><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>原子性是数据库的事务中的特性,在数据库事务的情景下,原子性指的是:一个事务(transaction)中的所有操作,要么全部完成,要么全部不完成,不会结束在中间某个环节</p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>redis的操作之所以是原子性,是因为Redis是单线程模型,而单线程的操作保证了一个线程的操作是不能被其他线程打断，同一时间只有一个线程对一个变量进行操作.在多线程情况下,每个线程的执行结果不受其他线程的干扰，比如说多个线程同时对同一个共享成员变量n++100次，如果n初始值为0，n最后的值应该是100，所以说它们是互不干扰的，这就是传说的中的原子性。但n++并不是原子性的操作，要使用AtomicInteger保证原子性</p><h2 id="单线程模型的优势"><a href="#单线程模型的优势" class="headerlink" title="单线程模型的优势"></a>单线程模型的优势</h2><p><strong>redis使用文本事件处理器file event handler ,整个文件事件处理器是单线程的,所以才叫做单线程模型</strong></p><ol><li>代码更清晰,处理逻辑更简单</li><li>不用去考虑各种锁的问题,不存在加锁释放锁的操作,没有因为可能出现死锁而导致的性能消耗</li><li>不存在多进程或者多线程导致的切换而消耗CPU</li><li>这里提一下缺点:无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善；</li></ol><p>这里扩展一下redis为什么是单线程模型的原因</p><ol><li><p>官方答案</p><p>​    因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了</p></li><li><p>性能指标</p><p>​    关于redis的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求</p></li><li><p>详细原因</p><p>​    a: 不需要各种锁的性能消耗</p><p>​        redis的数据结构并不是简单的key-Value,List,hash等复杂结构,这些结构有可能会进行很细粒度的操作,比如在很长的列表后面添加一个元素,在hash当中添加或者删除一个对象,这些操作可能就需要加非常多的锁,导致的结果是同步开销大大增加</p><p>​        总之，在单线程的情况下，就不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗</p><p>​      b:单线程多进程集群方案,单线程的威力实际上非常强大，每核心效率也非常高，多线程自然是可以比单线程有更高的性能上限，但是在今天的计算环境中，即使是单机多线程的上限也往往不能满足需要了，需要进一步摸索的是多服务器集群化的方案，这些方案中多线程的技术照样是用不上的</p><p>​        所以单线程,多进程的集群不失为一个时髦的解决发难</p><p>​        c:采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU,但是如果CPU成为Redis瓶颈，或者不想让服务器其他CUP核闲置，那怎么办？</p><p>​    可以考虑多起几个Redis进程(集群),Redis是key-value数据库，不是关系数据库，数据之间没有约束。只要客户端分清哪些key放在哪个Redis进程上就可以了​    </p></li></ol><h2 id="redis多线程"><a href="#redis多线程" class="headerlink" title="redis多线程"></a>redis多线程</h2><p>​    <strong>这里要说一下单线程是指模型不是单一的单线程</strong></p><p>Redis在处理 Redis在处理客户端的请求时，包括获取 (socket 读)、解析、执行、内容返回 (socket 写) 等都由一个顺序串行的主线程处理，这就是所谓的“单线程”。但如果严格来讲从Redis4.0之后并不是单线程，除了主线程外，它也有后台线程在处理一些较为缓慢的操作，例如清理脏数据、无用连接的释放、大 key 的删除等等</p><p><strong>单线程模型是指同一时刻内同时只能执行一个任务，其他任务都必须在后面排队等待</strong></p><p>​    官方曾经曾做过类似问题的回复：使用Redis时，几乎不存在CPU成为瓶颈的情况， Redis主要受限于内存和网络。例如在一个普通的Linux系统上，Redis通过使用pipelining每秒可以处理100万个请求，所以如果应用程序主要使用O(N)或O(log(N))的命令，它几乎不会占用太多CPU。</p><h3 id="redis以前不使用多线程的原因"><a href="#redis以前不使用多线程的原因" class="headerlink" title="redis以前不使用多线程的原因"></a>redis以前不使用多线程的原因</h3><p>单线程可维护性,多线程模型虽然在某些方面表现优异,但是它却引入了程序执行顺序的不确定性,带来了一系列的并发读写安全的问题，增加了系统复杂度,同时存在线程切换甚至加锁解锁、死锁造成的性能损耗。Redis通过AE事件模型以及IO多路复用等技术，处理性能非常高，因此没有必要使用多线程。单线程机制使得 Redis 内部实现的复杂度大大降低，Hash 的惰性 Rehash、Lpush 等等 “线程不安全” 的命令都可以无锁进行</p><h3 id="redis现在使用多线程模型的原因"><a href="#redis现在使用多线程模型的原因" class="headerlink" title="redis现在使用多线程模型的原因"></a>redis现在使用多线程模型的原因</h3><p>​    Redis将所有数据放在内存中，内存的响应时长大约为100纳秒，对于小数据包，Redis服务器可以处理80,000到100,000 QPS，这也是Redis处理的极限了,对于80%的公司来说单线程模型的redis已经够用了</p><p>​    但是随着越来越复杂的业务场景,有些公司动不动就上亿的交易量,因此需要更大的QPS。常见的解决方案是在分布式架构中对数据进行分区并采用多个服务器，但该方案有非常大的缺点，例如要管理的Redis服务器太多，维护代价大；某些适用于单个Redis服务器的命令不适用于数据分区；数据分区无法解决热点读/写问题；数据偏斜，重新分配和放大/缩小变得更加复杂等等</p><p>​    从redis自身角度来说,因为读写网络的read/write系统调用了Redis执行期间大部分CPU时间,瓶颈主要在于网络的IO消耗,优化主要有两个方向:</p><p>​    1.提高网络IO性能,典型的实现比如使用DPDK来代替内核网络栈的方法</p><p>​    2使用多线程充分利用多核，典型的实现比如 Memcached</p><p>协议栈优化的这种方式跟Redis关系不大，支持多线程是一种最有效最便捷的操作方式,所以总结起来,redis支持多线程主要就是原因:</p><p>​    1.可以充分利用服务器CPU资源,目前在主线程只能利用一个核</p><p>​    2.多线程任务可以分摊Redis同步IO读写负荷</p><h3 id="Redis6-0是否默认开启了多线程"><a href="#Redis6-0是否默认开启了多线程" class="headerlink" title="Redis6.0是否默认开启了多线程"></a>Redis6.0是否默认开启了多线程</h3><p>Redis6.0的多线程默认是禁用的，只使用主线程。如需开启需要修改redis.conf配置文件：</p><pre class="line-numbers language-linux"><code class="language-linux">io-threads-do-reads yes<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="http://qcro2d0lm.bkt.clouddn.com/redisDuoXianCheng1.png" alt=""></p><h3 id="Redis6-0多线程开启时-设置线程数"><a href="#Redis6-0多线程开启时-设置线程数" class="headerlink" title="Redis6.0多线程开启时,设置线程数"></a>Redis6.0多线程开启时,设置线程数</h3><p>开启多线程后，还需要设置线程数，否则是不生效的。同样修改redis.conf配置文件</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="http://qcro2d0lm.bkt.clouddn.com/RedisDuoXianCheng2.png" alt=""></p><p>关于线程数的设置,官方有一个建议:4核的机器建议设置为2或3个线程,8核的建议设置为6个线程,线程数一定小于机器核数,还需要注意的是，线程数并不是越大越好，官方认为超过了8个基本就没什么意义了</p><h3 id="redis6-0采用多线程后-性能提升效果"><a href="#redis6-0采用多线程后-性能提升效果" class="headerlink" title="redis6.0采用多线程后,性能提升效果"></a>redis6.0采用多线程后,性能提升效果</h3><p>redis作者antirez 在 RedisConf 2019分享时曾提到：Redis 6 引入的多线程 IO 特性对性能提升至少是一倍以上。国内也有大牛曾使用unstable版本在阿里云esc进行过测试，GET/SET 命令在4线程 IO时性能相比单线程是几乎是翻倍了</p><p>测试结果:<img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="http://qcro2d0lm.bkt.clouddn.com/redisTestResult.png" alt=""></p><p>具体测试连接:<a href="https://zhuanlan.zhihu.com/p/76788470" target="_blank" rel="noopener">详情</a></p><h2 id="IO多路复用技术"><a href="#IO多路复用技术" class="headerlink" title="IO多路复用技术"></a>IO多路复用技术</h2><p>redis 采用网络IO多路复用技术来保证在多连接的时候， 系统的高吞吐量</p><p>多路指的是多个socket连接,复用指的是复用一个线程,多路复用主要有三种技术:select,poll,epoll也是最新的也是目前最好的多路复用技术</p><p>这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路I/O</p><p>复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），且Redis在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了Redis具有很高的吞吐量</p><p>图<img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="http://qcro2d0lm.bkt.clouddn.com/IOfuyong.png" alt=""></p><h2 id="总结Redis高并发性的原因"><a href="#总结Redis高并发性的原因" class="headerlink" title="总结Redis高并发性的原因"></a>总结Redis高并发性的原因</h2><ol><li>redis是纯内存数据库,一般都是简单的存取操作,线程占用的时间很多，时间的花费主要集中在IO上，所以读取速度快.</li><li>再说一下IO，Redis使用的是非阻塞IO，IO多路复用，使用了单线程模型,来轮询描述符，将数据库的开、关、读、写都转换成了事件，减少了线程切换时上下文的切换和竞争(因时间片耗尽,线程已经获取了资源且下一个线程也需要用)</li><li>Redis采用了单线程的模型，保证了每个操作的原子性，也减少了线程的上下文切换和竞争,其redis本身提供的所有API都是原子操作,redis中的事务其实是要保证批量操作的原子性</li><li>另外，数据结构也帮了不少忙，Redis全程使用hash结构，读取速度快，还有一些特殊的数据结构，对数据存储进行了优化，如压缩表，对短数据进行压缩存储，再如，跳表，使用有序的数据结构加快读取的速度</li><li>Redis采用自己实现的事件分离器，效率比较高，内部采用非阻塞的执行方式，吞吐能力比较大</li></ol><p>图:<img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="http://qcro2d0lm.bkt.clouddn.com/redisHightFalse.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis第一天安装</title>
      <link href="/2020/01/27/redis/"/>
      <url>/2020/01/27/redis/</url>
      
        <content type="html"><![CDATA[<h1 id="redis-第一天-安装"><a href="#redis-第一天-安装" class="headerlink" title="redis-第一天 -安装"></a>redis-第一天 -安装</h1><h2 id="redis-传输到Linux"><a href="#redis-传输到Linux" class="headerlink" title="redis-传输到Linux"></a>redis-传输到Linux</h2><p>首先你需要一定的linux基础,以及熟悉一些linux命令,方便以后你对它的一些操作,如果需要,请看我出的上一边linux基础</p><p>进入redis<a href="https://redis.io/" target="_blank" rel="noopener">官网</a>后你会发现现在redis都更新到6.0版本了,但是本次我们只实现5.0版本的,在官网你需要进行如下操作</p><p>步骤:</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="http://qcro2d0lm.bkt.clouddn.com/redisGuanWang1.png" alt=""></p><ol><li>点击官网导航栏的 Download进入到下载页面</li><li>在Other versions下有个Old(5.0)点击<a href="http://download.redis.io/releases/redis-5.0.8.tar.gz" target="_blank" rel="noopener">下载连接</a>注意它下载是个tar.gz文件所有需要在linux系统下解压</li></ol><p>下载完成你需要打开一个虚拟机 使用xshell连接,文件上传工具Xftp工具,如果有需要这些工具的朋友请联系我QQ:1776099164</p><p><strong>步骤:这些操作注意都在根目录下,方便后续查找</strong></p><p>切换根目录 </p><pre class="line-numbers language-linux"><code class="language-linux">cd ~<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>图:<img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="http://qcro2d0lm.bkt.clouddn.com/linuxRedisCS.png" alt=""></p><p>上传成功后在xshell下执行命令</p><pre class="line-numbers language-linux"><code class="language-linux">ll<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​                图:<img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="http://qcro2d0lm.bkt.clouddn.com/redisAn2.png" alt=""></p><p>当显出有文件redis-5.0.3.tar.gz你的redis安装包就上传成功到了linux击掌把嘿嘿</p><h2 id="redis-单机安装"><a href="#redis-单机安装" class="headerlink" title="redis-单机安装"></a>redis-单机安装</h2><p>在目录下创建一个目录存放redis</p><pre class="line-numbers language-linux"><code class="language-linux">mkdir /usr/local/redis<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后使用命令解压安装包</p><pre class="line-numbers language-linux"><code class="language-linux">tar zxvf redis-5.0.3.tar.gz <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后安装依赖 在根目录下</p><pre class="line-numbers language-linux"><code class="language-linux">yum -y install gcc-c++ autoconf automake<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>图:</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="http://qcro2d0lm.bkt.clouddn.com/redisYiLai.png" alt=""></p><p>然后切换到安装的包里进行预编译</p><pre><code>cd redis-5.0.3</code></pre><pre class="line-numbers language-linux"><code class="language-linux">make<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="http://qcro2d0lm.bkt.clouddn.com/RedisYuBianYi.png" alt=""></p><p>使用make install 指定安装路径 ,需要添加PREFIX 参数 ,不使用make install默认是安装到 /usr/local/bin 目录下</p><pre class="line-numbers language-linux"><code class="language-linux">make PREFIX=/usr/local/redis/ install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="http://qcro2d0lm.bkt.clouddn.com/redisAn5.png" alt=""></p><p>切换到指定目录下查看是否安装成功</p><pre class="line-numbers language-linux"><code class="language-linux">cd /usr/local/redis/bin   #切换路径ll        #查看安装的文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>安装成功如图</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="http://qcro2d0lm.bkt.clouddn.com/redisAn6.png" alt=""></p><p>这里说一下这5个文件的目录</p><ol><li>redis-benchmark : redis自带的性能测试工具</li><li>redis-check-aof: 用于更新日志检查的实现</li><li>redis-check-dump:用于本地数据库检查的实现</li><li>redis-cli:客户端</li><li>redis-sentinel:哨兵</li><li>redis-server:服务端</li></ol><h2 id="启动单机"><a href="#启动单机" class="headerlink" title="启动单机"></a>启动单机</h2><p>切换到安装路径</p><pre class="line-numbers language-linux"><code class="language-linux">cd /usr/local/redis<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    图:</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="http://qcro2d0lm.bkt.clouddn.com/RedisAn7.png" alt=""></p><p>输入启动命令</p><pre class="line-numbers language-linux"><code class="language-linux">./redis-server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    图:成功启动</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="http://qcro2d0lm.bkt.clouddn.com/redisStart.png" alt=""></p><p>默认这是前台启动,一般为了方便我们会修改为后台启动</p><p>在根目录下查看解压后的redis安装包找到redis.conf文件,然后为了以后方便拷贝一份到安装路径下</p><pre class="line-numbers language-linux"><code class="language-linux">cp redis.conf /usr/local/redis/bin/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>切换到安装路径下的redis.conf,将其内容的daemonize修改为yes</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="http://qcro2d0lm.bkt.clouddn.com/redisAn8.png" alt=""></p><p>然后在启动的时候指定为配置文件启动,注意启动的时候在安装路径的bin目录下</p><pre class="line-numbers language-linux"><code class="language-linux">./redis-server ./redis.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>你可以在使用命令查看是否有这进程查看redis是否启动</p><pre class="line-numbers language-llinux"><code class="language-llinux">ps -ef|grep redis<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="http://qcro2d0lm.bkt.clouddn.com/redisAn9.png" alt=""></p><p>这样你的redis就成功启动了,加油啊,后面困难越来越多</p><h2 id="通过windows客户端访问redis"><a href="#通过windows客户端访问redis" class="headerlink" title="通过windows客户端访问redis"></a>通过windows客户端访问redis</h2><p>安装redis客户端连接工具,这里网上和github上有很多,这里我使用我找到的一个工具</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="http://qcro2d0lm.bkt.clouddn.com/redisGongJu.png" alt=""></p><p>单机连接到服务器输入你的连接的名字,可以自定义, Host,为你的虚拟机的ip 端口默认为6379,然后点击测试连接,这里会连接失败</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="http://qcro2d0lm.bkt.clouddn.com/RedisKeHu.png" alt=""></p><p>需要修改一些配置文件</p><ol><li>注释掉bind 127.0.0.1 可以使所有的ip访问redis，若是想指定多个ip访问，但并不是全部的ip访问，可以bind设置 <img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="http://qcro2d0lm.bkt.clouddn.com/redisPeiZhi1.png" alt=""></li></ol><p>2.关闭保护模式，修改为no <img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="http://qcro2d0lm.bkt.clouddn.com/redisPeizhi2.png" alt=""></p><p>3.添加访问认证 <img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="http://qcro2d0lm.bkt.clouddn.com/RedisPeiZhi3.png" alt=""></p><p>记得把进程杀死重启redis,使修改后的配置生效</p><pre class="line-numbers language-linux"><code class="language-linux">kill -9 XXXXX #这里指的是你的Redis的进程号,可以使用 ps -ef|grep redis 查看<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="http://qcro2d0lm.bkt.clouddn.com/RedisAn11.png" alt=""></p><p>然后再次使用客户端去连接使用,<img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="http://qcro2d0lm.bkt.clouddn.com/RedisTestConn.png" alt=""></p><p>当显示连接成功你的Redis就已经可以通过本地连接</p><p>当我们连接本地看得时候发现默认为16个库这时候我们也可以通过修改redis.conf中的配置使库为你想要的个数<img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="http://qcro2d0lm.bkt.clouddn.com/RedisAn12.png" alt=""></p><p>然后杀死进程重启redis使,客户端重新连接redis查看库是否被修改<img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="http://qcro2d0lm.bkt.clouddn.com/RedisAn15.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Redis的第一天 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多级缓存设计</title>
      <link href="/2020/01/25/duo-ji-huan-cun-de-she-ji/"/>
      <url>/2020/01/25/duo-ji-huan-cun-de-she-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="多级缓存设计"><a href="#多级缓存设计" class="headerlink" title="多级缓存设计"></a>多级缓存设计</h1><h2 id="设计缓存的原因-演变史"><a href="#设计缓存的原因-演变史" class="headerlink" title="设计缓存的原因-演变史"></a>设计缓存的原因-演变史</h2><p>​    其实高并发应对的解决方案并不是因为互联网出现,早在很久以前,计算机先祖们就对类似的场景做了方案,比如在《计算机组成原理》一书中,曾经提到了cpu缓存概念,他是一种高速缓存,容量比内存小但是速度快,所以缓存的出现主要是为了解决cpu运算速度远大于内存读写速度,甚至达到千万倍</p><h2 id="cpu"><a href="#cpu" class="headerlink" title="cpu"></a>cpu</h2><p>​    传统的cpu通过fsb直连内存的方式显然会因为内存访问的等待,导致cpu的吞吐量下降,内存成为性能瓶颈.同时又由于内存访问的热点数据集中性,所以在cpu与内存做一层临时的存储器作为高速缓存</p><h2 id="变迁"><a href="#变迁" class="headerlink" title="变迁"></a>变迁</h2><p>​    随着系统复杂性的提升,这种高速缓存和内存之间的速度进一步拉开,由于技术难度和成本等原因,所以有了更大的二级,三级缓存。根据读取顺序,绝大多数的请求首先落在一级请求,其次二级…….,故而应用于SOA甚至微服务场景,内存相当于储存业务数据的持久化数据库,其吞吐量肯定远远小于缓存的,相对于java程序来讲,本地jvm的缓存优于集中式的redis缓存。</p><p>​    关系型数据库操作方便,易于维护访问数据灵活,但是随着数据量的增加,其检索,更新的效率会越来越低.所以在高并发低延迟要求复杂的场景,要给数据库减负,减少其压力</p><h2 id="数据库减负"><a href="#数据库减负" class="headerlink" title="数据库减负"></a>数据库减负</h2><p><strong>1.做多级缓存</strong></p><p>​    <strong>读请求时写缓存</strong></p><p>写缓存一级一级写,先写本地缓存,再写集中式缓存.具体缓存的方法可以与很多种,但是需要注意几项原则:</p><p>​    1.尽量不要复制粘贴,不利于后期维护</p><p>​    2.切忌和业务耦合太紧,不利于后期维护</p><p>​    3.开发初期刚刚上线阶段,为了排查问题,常常会给缓存设置开关,但是开关设置多了则会同时提升高系统的复杂度,需要结合一套统一配置管理系统</p><p>​    综上所诉,高耦合带来的痛,弥补的代价是很大的,所以借鉴spring cache来实现,实现也简单,使用的时候一个注解就搞定</p><p>​    当写缓存失败了怎么办?应该是先写缓存还是数据库?</p><p>​    1.既然是缓存的设计,那么策略一定是保证最终的一致性,那么我们只需要采用异步消息补偿就行了</p><p>​    2.大部分缓存应用的场景是读写比差异很大的,读远大于写,在这种场景,先写数据库,再写缓存</p><p>​    3最后补充一点,数据库出现异常时,要把具体关心的异常往外抛,然后进行有针对性地异常处理</p><p><strong>关系其它性能方面</strong></p><p>缓存设计都是占用越少越好,内存资源以及太大不好维护都驱使我们设计.所以要尽可能减少缓存不必要地数据,有的人图省事把整个对象序列化储存.另外,序列化与反序列化也是消耗性能的</p><h2 id="各种缓存同步方案"><a href="#各种缓存同步方案" class="headerlink" title="各种缓存同步方案"></a>各种缓存同步方案</h2><p>缓存同步的方案有很多种,在考虑一致性,数据库访问压力,实时性等方面做权衡,总的来说有以下几种方式:</p><p><strong>1.懒加载</strong></p><p>读时顺便加载.为了更新缓存数据,需要过期缓存</p><p>​    优点:简单直接</p><p>​    缺点:会造成一次缓存不命中,这样当用户并发很大时,恰好缓存中无数据，数据库承担瞬时流量过大会造成风险</p><p>懒加载式太简单,没有自动加载,异步刷新等机制,为了弥补其缺陷,提供了两种方法</p><p>​    <strong>补充式</strong></p><p>​    可以在缓存时,把过期时间等信息写到一个异步队列里,后台起个线程池定期扫描这个队列,在快过期时主动reload缓存,使得数据会一直保持在缓存中,如果缓存没有也没有必要去数据库查询</p><p>优点: 刷新缓存变为异步得任务,对数据库的压力瞬间由于任务队列的介入而降低了,削皮并发的波峰</p><p>缺点:消息一旦积压会造成同步延迟,引入复杂度</p><p>​    <strong>定时加载式</strong></p><p>​    需要一个异步线程池定期把数据库的数据刷到集中式缓存,如redis里</p><p>优点:保证所有数据最小时间差同步到缓存中,延迟很低</p><p>缺点:如补充式,需要一个任务调度框架,复杂度提升,且要保证任务的顺序.如果递进一步还想加载到本地缓存,就得本地应用自己起线程抓取,方案维护成本高.可以考虑使用mq或者其它异步任务调度框架</p><p>ps:为了防止队列过大调度出现问题,处理完的数据要尽快结转,且要对积压数据以及写入情况做监控。</p><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>是指查询的key压根不存在,从而缓存查询不到而查询数据库,若是这样的key恰好并发请求很大，那么就会对数据库造成不必要的压力,</p><p><strong>解决方案</strong></p><p>​    把所有的key都存在另一个存储的Set集合里,查询时可以先查讯key是否存在,也可以设置简单些,给查询不到的key加一个标识空值的Value,这样就不会去查询数据库了,比如,你想要去查询某市区街道对应的营业厅,若是某街道确实没有移动营业厅,key的规则不变,但是value值可以设置为0等无意义的字符,当然这种方案必须保证缓存集群的高可用</p><p>​    这些key可能不是永远不存在,所以需要根据业务场景设置过期时间</p><h2 id="热点缓存与缓存淘汰策略"><a href="#热点缓存与缓存淘汰策略" class="headerlink" title="热点缓存与缓存淘汰策略"></a>热点缓存与缓存淘汰策略</h2><p>有一些场景,需要只保持一部分的热点缓存,不需要全量缓存,比如热卖的商品信息,购买某类的热门商圈信息</p><p><strong>根据我总结缓存的策略有以下三种</strong></p><h3 id="FIFO-First-In-First-Out"><a href="#FIFO-First-In-First-Out" class="headerlink" title="FIFO(First In,First Out)"></a>FIFO(First In,First Out)</h3><p>先进先出,淘汰最早进来的缓存数据,一个标准的队列,以队列为基本数据队列,以队首进入新数据，从队尾淘汰.</p><h3 id="LRU-Least-RecentlyUsed"><a href="#LRU-Least-RecentlyUsed" class="headerlink" title="LRU(Least RecentlyUsed)"></a>LRU(Least RecentlyUsed)</h3><p>一般很少使用,淘汰最近不使用的缓存数据,如果数据最近被访问过,则不被淘汰,和FIFO不同的是,需要对链表做基本模型,读写的时间复杂度是O(1),写入新数据进入头部,表满了数据从尾部淘汰;</p><p>最近时间被访问的数据移到头部,实现算法有很多,如hashmap+双向链表等待.但是如果某些key偶发性被最近频繁访问,并不是常态,则数据收到污染</p><h3 id="LFU-Least-Frequently-used"><a href="#LFU-Least-Frequently-used" class="headerlink" title="LFU(Least Frequently used)"></a>LFU(Least Frequently used)</h3><p>最近使用次数最少的数据被淘汰,注意和LRU的区别在于LRU的淘汰规则则是基于访问时间.</p><p>LFU每个数据块都有一个引用计数,数据块按照引用基数排序,若是恰好具有相同引用计数的数据块则按照时间排序；</p><p>因为新加入的数据访问次数为1,所以插入到队列尾部</p><p>队列中的数据被新访问后,引用技术增加,队列重新排序;</p><p>当需要淘汰数据时,将已经排序的列表最后的数据块删除,</p><p>这样会产生一个很明显的问题是若短时间内被频繁访问多次,比如访问异常或者循环没有控制住,而后很长时间未使用,则此数据会因为频率高而被错误的保留下来没有被淘汰.尤其对于新的数据,由于其起始的次数是1,所以即使被正常使用也会因为比不过老的数据而被淘汰.所以维基百科说纯粹的LFU算法不经常单独使用而是组合在其他策略中使用</p><h2 id="缓存中使用常见的一种问题"><a href="#缓存中使用常见的一种问题" class="headerlink" title="缓存中使用常见的一种问题"></a>缓存中使用常见的一种问题</h2><ol><li>那么应该选择用本地缓存还是集中式缓存(Cache cluster)呢?</li></ol><p>首先看数据量,看缓存的更新的成本,如果整体缓存数据量不大,而且变化的不频繁,那么建议本地缓存</p><ol start="2"><li>怎么批量更新一批缓存数据</li></ol><p>依次从数据库读取,然后批量写入缓存,批量更新,设置版本过期key或者主动删除</p><ol start="3"><li>如果不知道与那些key怎么定期删除</li></ol><p>拿redis来说key * 太损耗性能,不推荐.可以指定一定集合,把所有的key都存到这个集合中,</p><p>然后对整个集合进行删除,这样便能完全清理</p><ol start="4"><li><p>一个key包含的集合很大,redis无法做到内存空间上的均匀Shard</p><p>a:可以简单的设置key过期,这样就要允许有缓存不命中的情况,</p><p>b:给key设置版本,比如为两天后的当前时间,然后读取缓存时用时间判断是否需要重新加载,作为版本过期策略</p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Redis的第一天 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HaspMap并发问题</title>
      <link href="/2019/11/25/hashmap/"/>
      <url>/2019/11/25/hashmap/</url>
      
        <content type="html"><![CDATA[<h1 id="HashMap并发安全"><a href="#HashMap并发安全" class="headerlink" title="HashMap并发安全"></a>HashMap并发安全</h1><h2 id="jdk-1-7"><a href="#jdk-1-7" class="headerlink" title="jdk-1.7"></a>jdk-1.7</h2><p>HashMap是Java中最常用的一个Map实现类,其键值对也是key-value形式,其数据结构采用了位桶和链表的相结合的形式,也就是通俗的拉链法</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="http://qcro2d0lm.bkt.clouddn.com/Jdk17HaspMap.png" alt=""></p><p>HaspMap里储存的是静态的Entry对象,也是key-value形式</p><p>一定要注意Entry这里在1.8为了解决时其产生的一些bug改用node</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> K key<span class="token punctuation">;</span>        V value<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/** 指向下一个元素的引用 */</span>        Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span>        <span class="token keyword">int</span> hash<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/**         * 构造方法为Entry赋值         */</span>        <span class="token function">Entry</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">,</span> K k<span class="token punctuation">,</span> V v<span class="token punctuation">,</span> Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>            value <span class="token operator">=</span> v<span class="token punctuation">;</span>            next <span class="token operator">=</span> n<span class="token punctuation">;</span>            key <span class="token operator">=</span> k<span class="token punctuation">;</span>            hash <span class="token operator">=</span> h<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出,Entry就是数组的元素,每一个Map.entry其实就是一个key-value对，它持有一个指向下一个元素的引用,这样就构成了链表</p><p><strong>存</strong></p><p>当我们往HashMap中put元素的时候,先根据key的hashCode重新计算hash值,根据hash值得到这个元素在数组得位置,也就是下标,如果数组在该位置上存放有其他元素,那么在这个位置上得元素将以链表得形式存放,新加入得放在表头,现在加入得放在链尾,如果该位置上没有元素,就直接将该元素放在此数组中得该位置</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// HashMap允许存放null键和null值。</span>    <span class="token comment" spellcheck="true">// 当key为null时，调用putForNullKey方法，将value放置在数组第一个位置。 </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">putForNullKey</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 根据key的keyCode重新计算hash值。</span>    <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 搜索指定hash值在对应table中的索引。</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果 i 索引处的 Entry 不为 null，通过循环不断遍历 e 元素的下一个元素。</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> null<span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Object k<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">recordAccess</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 如果i索引处的Entry为null，表明此处还没有Entry。</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将key、value添加到i索引处。</span>    <span class="token function">addEntry</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意当hashMap存储key-value时只考虑到了Entry中得value,仅仅是根据key计算出每一个Entry得存储位置,我们可以把value当成key得附属,当系统决定了key得存储位置后,value也随之保存</p><p>key在其重新计算一次散列中,加入了高位计算,以达到防止地位不变,高位变化时,造成hash碰撞</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>    h <span class="token operator">^=</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="并发的问题"><a href="#并发的问题" class="headerlink" title="并发的问题"></a>并发的问题</h3><p>1.形成环形链表,导致数据无法插入</p><p>案列演示:</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashMapTest</span> <span class="token punctuation">{</span>            Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span>map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> <span class="token function">String</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            CountDownLatch countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token annotation punctuation">@Test</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 1|9的index为2 </span>                map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"9"</span><span class="token punctuation">,</span> <span class="token string">"9"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 6的index为1</span>                map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"6"</span><span class="token punctuation">,</span> <span class="token string">"6"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 3的index为0</span>                map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"3"</span><span class="token punctuation">,</span> <span class="token string">"3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 4的index为3</span>                map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"4"</span><span class="token punctuation">,</span> <span class="token string">"4"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                Thread thread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TestThread</span><span class="token punctuation">(</span><span class="token string">"thread----1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                Thread thread2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TestThread</span><span class="token punctuation">(</span><span class="token string">"thread----2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                thread1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                thread2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 此时就会遍历到成环的链表 导致死循环</span>                map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"10"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">class</span> <span class="token class-name">TestThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span><span class="token punctuation">{</span>                <span class="token keyword">public</span> <span class="token function">TestThread</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"5"</span><span class="token punctuation">,</span> <span class="token string">"5"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 遍历输入map中元素会导致内存溢出</span>                    <span class="token comment" spellcheck="true">// System.out.println(map);</span>                    countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>分析</strong></p><p>1.往hashMap里面添加5个元素后启动两个线程thread1和thread2,这两个线程同时会往map新增一个元素,因为此时HashMap里面已有5个元素（大于默认扩容阈值3），且数组上每个位置都已有元素，因此在新增元素时会满足扩容的条件</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="http://qcro2d0lm.bkt.clouddn.com/%E5%86%85%E5%AD%981.png" alt=""></p><p>扩容源码</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">addEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">int</span> bucketIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">>=</span> threshold<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">resize</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>            hash <span class="token operator">=</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> key<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>            bucketIndex <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">createEntry</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> bucketIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>扩容顺序</p><pre class="line-numbers language-java"><code class="language-java"><span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token operator">--</span><span class="token operator">></span>   <span class="token function">addEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">int</span> bucketIndex<span class="token punctuation">)</span> <span class="token operator">--</span><span class="token operator">></span><span class="token function">resize</span><span class="token punctuation">(</span><span class="token keyword">int</span> newCapacity<span class="token punctuation">)</span> <span class="token operator">--</span><span class="token operator">></span> <span class="token function">transfer</span><span class="token punctuation">(</span>Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> newTable<span class="token punctuation">,</span> <span class="token keyword">boolean</span> rehash<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后在transfer方法里在e.next = newTable[i]这一行打好断点,让两个线程都停顿在这一行</p><p>接着执行两个线程，让两个线程都遍历到第三个元素后还是停顿到e.next = newTable[i];这一行。此时两个线程中变量的值如下</p><pre class="line-numbers language-java"><code class="language-java">e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">)</span>next <span class="token operator">=</span> （<span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span>）Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next <span class="token operator">=</span> e<span class="token punctuation">.</span>next <span class="token operator">=</span> （<span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span>）newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> null<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>执行完线程thread1，thread2不动。thread1扩容完成之后，因为尾插法和重新计算了一遍元素所在数组上的索引，所以此时HashMap中的元素结构如下（直接以key来展示):</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="http://qcro2d0lm.bkt.clouddn.com/%E9%A1%BA%E5%BA%8F1.png" alt=""></p><p>​    此时新数组上table[2]=1，table[2].next()=9</p><p>此时再看thread2，此时可以发现e.next已经等于null了。也就是说在thread1扩容完之后，thread1工作内存中链表的顺序已经通过主内存同步到thread2的工作内存来了。此时因为thread2已经通过主内存同步到了thread1中链表的顺序导致e.next为null，所以线程中变量如下：</p><pre class="line-numbers language-java"><code class="language-java">e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">)</span>next <span class="token operator">=</span> （<span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span>）Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next <span class="token operator">=</span> e<span class="token punctuation">.</span>next <span class="token operator">=</span> nullnewTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nul<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>经过transfer方法赋值后的结果顺序</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="http://qcro2d0lm.bkt.clouddn.com/%E6%9C%BA%E6%9E%84%E5%9B%BE.png" alt=""></p><p>因为e为（9,9）这一次遍历操作时，next还是（1,1），且最终将next赋值给了e，所以接下来遍历处理（1,1）。同时还是因为thread2同步到了thread1中的链表顺序，所以（1,1）元素的next指向了（9,9）。<br>此时线程中变量如下</p><pre class="line-numbers language-java"><code class="language-java">e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>next <span class="token operator">=</span> （<span class="token number">9</span><span class="token punctuation">,</span><span class="token number">9</span>）Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next <span class="token operator">=</span> e<span class="token punctuation">.</span>next <span class="token operator">=</span> （<span class="token number">9</span><span class="token punctuation">,</span><span class="token number">9</span>）newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> （<span class="token number">9</span><span class="token punctuation">,</span><span class="token number">9</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="http://qcro2d0lm.bkt.clouddn.com/tu1.png" alt=""></p><p>继续遍历（1,1）元素next执行的元素（9,9），此时线程中变量如下</p><pre class="line-numbers language-java"><code class="language-java">e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">)</span>next <span class="token operator">=</span> nullEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next <span class="token operator">=</span> e<span class="token punctuation">.</span>next <span class="token operator">=</span> nullnewTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>经过transfer方法的最后三行赋值操作之后，HashMap元素结构如下（直接以key来展示）</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="http://qcro2d0lm.bkt.clouddn.com/tu3.png" alt=""></p><p>可以看到此时key为1和9的元素已经成环了，此时还没有报错，当对map进行一下操作出现问题</p><ol><li>对它做遍历操作，因为要对整个map遍历，到了环形链表那里就出不来了。</li><li>如果是像上面的demo那样直接打印整个map，因为遍历死循环里面叠加的字符串会越来越大，最终会直接导致内存溢出</li></ol><p>异常错误代码:</p><pre class="line-numbers language-java"><code class="language-java">Exception in thread <span class="token string">"thread----2"</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>OutOfMemoryError<span class="token operator">:</span> Java heap space    at java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">2367</span><span class="token punctuation">)</span>    at java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>AbstractStringBuilder<span class="token punctuation">.</span><span class="token function">expandCapacity</span><span class="token punctuation">(</span>AbstractStringBuilder<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">130</span><span class="token punctuation">)</span>    at java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>AbstractStringBuilder<span class="token punctuation">.</span><span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>AbstractStringBuilder<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">114</span><span class="token punctuation">)</span>    at java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>AbstractStringBuilder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>AbstractStringBuilder<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">415</span><span class="token punctuation">)</span>    at java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>StringBuilder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>StringBuilder<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">132</span><span class="token punctuation">)</span>    at java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>StringBuilder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>StringBuilder<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">128</span><span class="token punctuation">)</span>    at java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>AbstractMap<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>AbstractMap<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">521</span><span class="token punctuation">)</span>    at java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">2847</span><span class="token punctuation">)</span>    at java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>PrintStream<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>PrintStream<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">821</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>对它进行get操作,get的key计算出来的索引位置就是环形链表的索引位置且key不存在于map中，这样也会无限遍历下去</li></ol><h2 id="jdk-1-8"><a href="#jdk-1-8" class="headerlink" title="jdk-1.8"></a>jdk-1.8</h2><p>Hash表是一个数组+链表的结构，这种结构能够保证在遍历与增删的过程中，如果不产生hash碰撞，仅需一次定位就可完成，时间复杂度能保证在O(1)。  在jdk1.7中，只是单纯的数组+链表的结构，但是如果散列表中的hash碰撞过多时，会造成效率的降低，所以在JKD1.8中对这种情况进行了控制，当一个hash值上的链表长度大于8时，该节点上的数据就不再以链表进行存储，而是转成了一个红黑树</p><p><strong>hasp碰撞</strong></p><p>hash是指，两个元素通过hash函数计算出的值是一样的，是同一个存储地址。当后面的元素要插入到这个地址时，发现已经被占用了，这时候就产生了hash冲突</p><p>解决:</p><p>开放定址法(查询产生冲突的下一个地址是否被占用,直到找到空的地址),再散列法,链地址法.hashMap也是采用链地址法,jdk1.7中，当冲突时，在冲突的地址上生成一个链表，将冲突的元素的key，通过equals进行比较，相同即覆盖，不同则添加到链表上，此时如果链表过长，效率就会大大降低，查找和添加操作的时间复杂度都为O(n)；但是在jdk1.8中如果链表长度大于8，链表就会转化为红黑树，时间复杂度也降为了O(logn)，性能得到了很大的优化</p><p><strong>实现</strong></p><p>​    在1.8中hashMap的主干是一个Node数组(jdk1.7及之前为Entry数组)每一个Node包含一个key与value的键值对，与一个next</p><p>next指向下一个node，hashMap由多个Node对象组成</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span>        <span class="token keyword">final</span> K key<span class="token punctuation">;</span>        V value<span class="token punctuation">;</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span>        <span class="token function">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>hash <span class="token operator">=</span> hash<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> K <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span> <span class="token keyword">return</span> key<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> V <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span> <span class="token keyword">return</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> key <span class="token operator">+</span> <span class="token string">"="</span> <span class="token operator">+</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> Objects<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">^</span> Objects<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> V <span class="token function">setValue</span><span class="token punctuation">(</span>V newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>            V oldValue <span class="token operator">=</span> value<span class="token punctuation">;</span>            value <span class="token operator">=</span> newValue<span class="token punctuation">;</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">this</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token keyword">instanceof</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token operator">></span> e <span class="token operator">=</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">)</span>o<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>Objects<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                    Objects<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>重要的几个字段</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//默认初始容量为16，0000 0001 右移4位 0001 0000为16，主干数组的初始容量为16，而且这个数组</span><span class="token comment" spellcheck="true">//必须是2的倍数(后面说为什么是2的倍数)</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_INITIAL_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// aka 16</span><span class="token comment" spellcheck="true">//最大容量为int的最大值除2</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAXIMUM_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//默认加载因子为0.75</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> DEFAULT_LOAD_FACTOR <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//阈值，如果主干数组上的链表的长度大于8，链表转化为红黑树</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//hash表扩容后，如果发现某一个红黑树的长度小于6，则会重新退化为链表</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> UNTREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//当hashmap容量大于64时，链表才能转成红黑树</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MIN_TREEIFY_CAPACITY <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//临界值=主干数组容量*负载因子</span><span class="token keyword">int</span> threshold<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>put的过程</strong></p><p>然后将key传入hash方法，计算其对应的hash值：</p><p>此处如果传入的int类型的值：①向一个Object类型赋值一个int的值时，会将int值自动封箱为Integer。②integer类型的hashcode都是他自身的值，即h=key；h &gt;&gt;&gt; 16为无符号右移16位，低位挤走，高位补0；^ 为按位异或，即转成二进制后，相异为1，相同为0，由此可发现，当传入的值小于  2的16次方-1 时，调用这个方法返回的值，都是自身的值</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span>V value<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span>key value<span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="http://qcro2d0lm.bkt.clouddn.com/%E5%B9%B6%E5%8F%91.jpg" alt=""></p><p>再执行putVal方法这里产生了一些不安全</p><p><strong>原因</strong></p><p>在jdk1.7的一些问题在jdk1.8得到了很好的解决,如果你去阅读1.8的源码会发现根本找不大transfer函数,因为jdk直接在resize函数中完成了数据迁移,再提一下jdk1.8以前都是头插法,1.8都是尾插法</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">final</span> V <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span>                   <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 如果没有hash碰撞则直接插入元素</span>            tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span> K k<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                e <span class="token operator">=</span> p<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> TREEIFY_THRESHOLD <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// -1 for 1st</span>                            <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                        <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    p <span class="token operator">=</span> e<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// existing mapping for key</span>                V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> null<span class="token punctuation">)</span>                    e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>                <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token operator">++</span>modCount<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">></span> threshold<span class="token punctuation">)</span>            <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    在这第6行判断是否出现hash碰撞，假设两个线程A、B都在进行put操作，并且hash函数计算出的插入下标是相同的，当线程A执行完第六行代码后由于时间片耗尽导致被挂起，而线程B得到时间片后在该下标处插入了元素，完成了正常的插入，然后线程A获得时间片，由于之前已经进行了hash碰撞的判断，所有此时不会再进行判断，而是直接进行插入，这就导致了线程B插入的数据被线程A覆盖了，从而线程不安全。<br>​    还有第38行有个++size我们这样想，还是线程A、B，这两个线程同时进行put操作时，假设当前HashMap的zise大小为10，当线程A执行到第38行代码时，从主内存中获得size的值为10后准备进行+1操作，但是由于时间片耗尽只好让出CPU，线程B快乐的拿到CPU还是从主内存中拿到size的值10进行+1操作，完成了put操作并将size=11写回主内存，然后线程A再次拿到CPU并继续执行(此时size的值仍为10)，当执行完put操作后，还是将size=11写回内存，此时，线程A、B都执行了一次put操作，但是size的值只增加了1，所有说还是由于数据覆盖又导致了线程不安全。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.在JDK1.7中，当并发执行扩容操作时会造成环形链和数据丢失的情况</p><p>2.在JDK1.8中，在并发执行put操作时会发生数据覆盖的情况</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> HaspMap并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> HaspMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HelloWorld</title>
      <link href="/2019/08/27/hello-world/"/>
      <url>/2019/08/27/hello-world/</url>
      
        <content type="html"><![CDATA[<pre><code>public class HelloWorld{    public static void main(String[] args){        System.out,printl("HelloWorld");    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 第一次使用hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Github </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
